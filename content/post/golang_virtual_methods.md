+++
categories = ["golang", "OOP", "nested structs"]
date = "2015-06-25T11:46:10+03:00"
description = "Лень двигатель прогресса. Серъёзно. Вот говорят вам не делайте так в Go, это неправильно, но порой ради того что-бы чуток сэкономить времени ты идёшь на ухищрения и внезапно симулируешь виртуальные методы, которых в Go отродясь не было и не будет никогда. Как и все ухищрения это костыль, неправильный и не красивый, но может кому и спасёт положение, потому что иногда бывает не в мочь - писать, писать, писать."
draft = false
keywords = ["golang", "OOP", "virtual methods", "nested structs"]
title = "Виртуальные методы в Golang"

+++
Дело было так. Когда-то когда я начинал только изучать Go, я всё ещё не вырвался из лап наследования в светлое композиционное будущее, поэтому мне жутко хотелось сделать эдакое, виртуальное, не очень большое из структур и методов к ним, что-бы можно было "как в Python-е", унаследовался понимаешь ли, переопределил метод, сделал своё грязное дело и вызвал родительский метод через super. И вот потратив много времени и сил, у меня это сделать не получилось. Точнее переопределить то метод не вопрос, Go поддерживает встраивание, и сделать это можно вот так:

---

``` golang
type Tree struct {}

fucn (t Tree) IsFoliar() bool {
    return false
}

func (t Tree) String() string {
    return "Tree"
}

// А вот здесь просто встроим первое во второе и у нас появятся
// все методы встраиваемой структуры
type Oak struct {
    Tree
}

// Сделаем shadow для этого метода
func (o Tree) IsFoliar() string {
    return true
}

tree := Oak{}
tree.IsFoliar() // вызывается метод Oak
tree.String() // вызывается метод Tree
```
Ну вроде всё хорошо. Но ведь нам нужен super. Тоесть мы хотим не только перехватить вызов метода, но и после выполнения отдать управление оригинальному методу. И вот тут можно долго чесать репу, но легального способа это сделать в принципе нет. Да и вообще когда такое может потребоваться? Ну может, может. Когда чуть-чуть надо изменить поведение одного метода, но не хочется описывать целый интерфейс. Вот пример, как это сделать:

``` golang
// SniffConn простой сниффинг входящих данных и дамп их в консоль
type SniffConn struct {
	*net.TCPConn
	w *net.TCPConn // и вот он костыль
}

// Я не хочу описывать весь net.Conn а всего-то хочу переопределить
// поведение одного метода
func (s *SniffConn) Read(b []byte) (int, error) {
	n, err := s.w.Read(b) // а вот использование костыля
	if err == nil {
		fmt.Println("# SNIFF RESPONSE:\n", string(b[:n]))
	}
	return n, err
}
```
Ну всё просто, хоть и безобразно и неправильно. Я шарясь по сислибам, не видел такого поведения пока, но что-то мне подсказывает что оно там есть, а как инициировать это дело вы и без меня знаете. Надеюсь не проклянёте меня за эту грязную игру - ну честно, было лень.
